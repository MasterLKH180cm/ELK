input {
  # Consume from domain-specific log topics via pattern matching
  # Topics: logs-{domain}-dev (frontend, backend, auth, security, payment, database, infra, default)
  kafka {
    bootstrap_servers => "${KAFKA_BROKERS:kafka:29092}"
    topics => ["otel-logs-frontend", "otel-logs-backend", "otel-logs-auth", "otel-logs-default"]
    group_id => "logstash-main-consumer"
    codec => json
    consumer_threads => 4
    poll_timeout_ms => 3000
    auto_offset_reset => "earliest"
    isolation_level => "read_committed"
    enable_auto_commit => true
    max_poll_records => 500
    session_timeout_ms => 30000
  }

  # Legacy: Keep fastapi-logs topic support for backward compatibility
  kafka {
    bootstrap_servers => "${KAFKA_BROKERS:kafka:29092}"
    topics => ["fastapi-logs"]
    group_id => "logstash-legacy-consumer"
    codec => json
    consumer_threads => 2
    poll_timeout_ms => 3000
    auto_offset_reset => "earliest"
    isolation_level => "read_committed"
    enable_auto_commit => true
    max_poll_records => 500
    session_timeout_ms => 30000
  }

  # HTTP endpoint for REST API logs (保留相容)
  http {
    port => 8081
    codec => json
    response_headers => {
      "Access-Control-Allow-Origin" => "*"
      "Access-Control-Allow-Headers" => "Content-Type"
      "Access-Control-Allow-Methods" => "POST, OPTIONS"
    }
  }

  # TCP endpoint for general logs (保留相容)
  tcp {
    port => 5000
    codec => json
  }

  # Beats input (保留相容)
  beats {
    port => 5044
  }
}

filter {
  # Extract event_domain from multiple sources (priority order)
  ruby {
    code => '
      # Priority 1: Direct event_domain field (from HTTP or direct Kafka producer)
      domain = event.get("event_domain")
      
      # Priority 2: Extract from Kafka topic name pattern: logs-{domain}-dev
      unless domain
        topic = event.get("[@metadata][kafka][topic]")
        if topic && topic.match?(/^logs-(\w+)-dev$/)
          domain = topic.match(/^logs-(\w+)-dev$/)[1]
        elsif topic && topic == "fastapi-logs"
          # Legacy: fastapi-logs must specify event_domain in message
          domain = event.get("event_domain") || "logs"
        elsif topic && topic == "otel-logs"
          domain = "logs"
        end
      end
      
      # Priority 3: Check nested OTEL fields
      unless domain
        domain = event.get("[body][attributes][event.domain]") ||
                 event.get("[body][event_domain]") ||
                 event.get("[attributes][event.domain]")
      end
      
      # Set domain, default to "logs" if not found
      event.set("event_domain", domain || "logs")
    '
  }

  # 標準化 @timestamp
  if [@timestamp] {
    date {
      match => ["@timestamp", "ISO8601"]
      target => "@timestamp"
      timezone => "UTC"
    }
  } else if [timestamp] {
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
      timezone => "UTC"
    }
  } else {
    ruby {
      code => 'event.set("@timestamp", Time.now.utc.iso8601(3))'
    }
  }

  # 提取 OTEL 屬性到頂層（便於查詢和分析）
  if [body][attributes] {
    ruby {
      code => '
        attrs = event.get("[body][attributes]")
        if attrs.is_a?(Hash)
          # 複製重要屬性到頂層
          event.set("[attributes]", attrs)
          event.set("[service_name]", attrs["service.name"])
          event.set("[service_namespace]", attrs["service.namespace"])
          event.set("[environment]", attrs["deployment.environment"])
          event.set("[event_domain]", attrs["event.domain"]) unless event.get("[event_domain]")
          event.set("[event_type]", attrs["event.type"])
          event.set("[event_category]", attrs["event.category"])
          event.set("[trace_id]", attrs["trace.id"])
          event.set("[span_id]", attrs["span.id"])
          event.set("[user_id]", attrs["user.id"])
          event.set("[session_id]", attrs["session.id"])
          event.set("[http_method]", attrs["http.method"])
          event.set("[http_status]", attrs["http.status_code"])
          event.set("[http_path]", attrs["http.path"])
          event.set("[duration_ms]", attrs["event.duration_ms"])
        end
      '
    }
  }

  # 計算延遲分類
  if [body][attributes][event.duration_ms] {
    ruby {
      code => '
        duration_ms = event.get("[body][attributes][event.duration_ms]")
        if duration_ms.is_a?(Numeric)
          case duration_ms
          when 0..100
            event.set("[latency_category]", "fast")
          when 100..500
            event.set("[latency_category]", "moderate")
          when 500..2000
            event.set("[latency_category]", "slow")
          else
            event.set("[latency_category]", "very_slow")
          end
        end
      '
    }
  }

  # 根據 event.domain 和 event.type 淨化敏感資訊
  if [body][attributes][event.type] == "audit" {
    # Audit logs: 保留更詳細的資訊，但仍需 PII stripping
    mutate {
      add_field => { "[log_classification]" => "audit" }
    }
  } else if [body][attributes][event.category] == "security" {
    # Security logs: 標記為安全相關
    mutate {
      add_field => { "[log_classification]" => "security" }
    }
  } else {
    mutate {
      add_field => { "[log_classification]" => "operational" }
    }
  }
}

output {
  # 根據 event.domain 寫入不同的數據流
  if [event_domain] == "auth" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      data_stream_type => "logs"
      data_stream_dataset => "auth"
      data_stream_namespace => "default"
      manage_template => false
      action => "create"
    }
  } else if [event_domain] == "frontend" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      data_stream_type => "logs"
      data_stream_dataset => "frontend"
      data_stream_namespace => "default"
      manage_template => false
      action => "create"
    }
  } else if [event_domain] == "backend" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      data_stream_type => "logs"
      data_stream_dataset => "backend"
      data_stream_namespace => "default"
      manage_template => false
      action => "create"
    }
  } else {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      data_stream_type => "logs"
      data_stream_dataset => "others"
      data_stream_namespace => "default"
      manage_template => false
      action => "create"
    }
  }

  # Debug output
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}

